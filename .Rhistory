str(stanfordheart)
start <- c(0, 3, -1)
laplacefit <- laplace(stanfordheart$transplantpost, start, stanfordheart)
str(stanfordheart)
laplacefit <- laplace(transplantpost, start, stanfordheart)
laplacefit
proposal <- list(var = laplacefit$var, scale = 2)
s <- rwmetrop(transplantpost, proposal, start, 10000, stanfordheart)
s$accept
par(mfrow = c(2, 2))
tau <- exp(s$par[ , 1])
plot(density(tau), main = "TAU")
lambda <- exp(s$par[ , 2])
plot(density(lambda), main = "LAMBDA")
p <- exp(s$par[ , 3])
plot(density(p), main = "P")
apply(exp(s$par), 2, quantile, c(0.05, 0.5, 0.95))
par(mfrow = c(1, 1))
t <- seq(1, 240)
p5 <- 0*t
p50 <- 0*t
p95 <- 0*t
for (j in 1:240) {
S <- (lambda/(lambda + t[j]))^p
q <- quantile(S, c(0.05, 0.5, 0.95))
p5[j] <- q[1]
p50[j] <- q[2]
p95[j] <- q[3]
}
plot(t, p50, type = "l", ylim = c(0, 1), ylab = "Prob(Survival)", xlab = "time")
lines(t, p5 , lty = 2)
lines(t, p95, lty = 2)
library(LearnBayes)
library(lattice)
str(sluggerdata)
logistic.fit <- function(player) {
d <- subset(sluggerdata, Player == player)
x <- d$Age
x2 <- d$Age^2
response <- cbind(d$HR, d$AB - d$HR)
list(Age = x, p = glm(response ~ x + x2, family = binomial)$fitted)
}
names <- unique(sluggerdata$Player)
newdata <- NULL
for (j in 1:9) {
fit <- logistic.fit(as.character(names[j]))
newdata <- rbind(newdata, data.frame(as.character(names[j]), fit$Age, fit$p))
}
names(newdata) <- c("Player", "Age", "Fitted")
xyplot(Fitted ~ Age | Player, data = newdata, type = "l", lwd = 3, col = "black")
xyplot(Fitted ~ Age | Player, data = newdata, type = "l", lwd = 3, col = "black")
library(LearnBayes)
library(lattice)
str(sluggerdata)
logistic.fit <- function(player) {
d <- subset(sluggerdata, Player == player)
x <- d$Age
x2 <- d$Age^2
response <- cbind(d$HR, d$AB - d$HR)
list(Age = x, p = glm(response ~ x + x2, family = binomial)$fitted)
}
names <- unique(sluggerdata$Player)
newdata <- NULL
for (j in 1:9) {
fit <- logistic.fit(as.character(names[j]))
newdata <- rbind(newdata, data.frame(as.character(names[j]), fit$Age, fit$p))
}
names(newdata) <- c("Player", "Age", "Fitted")
xyplot(Fitted ~ Age | Player, data = newdata, type = "l", lwd = 3, col = "black")
xyplot(Fitted ~ Age | Player, data = newdata, type = "l", lwd = 3, col = "black", layout = c(3, 3))
str(hearttransplants)
with(hearttransplants, plot(log(e), y/e, xlim = c(6, 9.7), xlab = "log(e)", ylab = "y/e"))
with(hearttransplants, text(log(e), y/e, labels = as.character(y), pos = 4))
sum(hearttransplants$y)
sum(hearttransplants$e)
lambda <- rgamma(1000, shape = 277, rate = 294681)
ys94 <- rpois(1000, e[94]*lambda)
ys94 <- rpois(1000, hearttransplants$e[94]*lambda)
hist(ys94, breaks = seq(0.5, max(ys94) + 0.5))
with(hearttransplants, lines(c(y[94], y[94]), c(0, 120), lwd = 3))
lambda <- rgamma(1000, shape = 277, rate = 294681)
prob.out <- function(i) {
ysi <- rpois(1000, e[i]*lambda)
pleft  <- sum(ysi <= y[i])/1000
pright <- sum(ysi >= y[i])/1000
min(pleft, pright)
}
prob.out <- function(i) {
ysi <- rpois(1000, hearttransplants$e[i]*lambda)
pleft  <- sum(ysi <= hearttransplants$y[i])/1000
pright <- sum(ysi >= hearttransplants$y[i])/1000
min(pleft, pright)
}
pout <- sapply(1:94, prob.out)
plot(log(e), pout, ylab = "Prob(extreme)")
plot(log(hearttransplants$e), pout, ylab = "Prob(extreme)")
pgexchprior <- function(lambda, pars) {
alpha <- pars[1]
a <- pars[2]
b <- pars[3]
(alpha - 1)*log(prod(lambda)) - (2*alpha + a)*log(alpha*sum(lambda) + b)
}
alpha <- c(5, 20, 80, 400)
par(mfrow = c(2, 2))
for (j in 1:4)
mycontour(pgexchprior, c(0.001, 5, 0.001, 5), c(alpha[j], 10, 10),
main = paste("ALPHA = ", alpha[j]), xlab = "LAMBDA 1", ylab = "LAMBDA 2")
datapar <- list(data = hearttransplants, z0 = 0.53)
start <- c(2, -7)
fit <- laplace(poissgamexch, start, datapar)
fit
par(mfrow = c(1, 1))
mycontour(poissgamexch, c(0, 8, -7.3, -6.6), datapar, xlab = "log alpha", ylab = "log mu")
start <- c(4, -7)
fitgibbs <- gibbs(poissgamexch, start, 1000, c(1, 0.15), datapar)
fitgibbs$accept
mycontour(poissgamexch, c(0, 8, -7.3, -6.6), datapar, xlab = "log alpha", ylab = "log mu")
points(fitgibbs$par[ , 1], fitgibbs$par[ , 2])
plot(density(fitgibbs$par[ , 1], bw = 0.2))
plot(density(fitgibbs$par[ , 1], bw = 0.2), main = "")
abline(v = 0, col = "grey")
plot(density(fitgibbs$par[ , 1], bw = 0.2), main = "")
abline(h = 0, col = "grey")
alpha <- exp(fitgibbs$par[ , 1])
mu <- exp(fitgibbs$par[ , 2])
lam1 <- rgamma(1000, y[1] + alpha, e[1] + alpha/mu)
lam1 <- with(hearttransplants, rgamma(1000, y[1] + alpha, e[1] + alpha/mu))
alpha <- exp(fitgibbs$par[ , 1])
mu <- exp(fitgibbs$par[ , 2])
with(hearttransplants, plot(log(e), y/e, pch = as.character(y)))
for (i in 1:94) {
lami <- with(hearttransplants, rgamma(1000, y[i] + alpha, e[i] + alpha/mu))
probint <- quantile(lami, c(0.05, 0.95))
lines(log(hearttransplants$e[i]) * c(1, 1), probint)
}
shrink <- function(i) mean(alpha/(alpha + e[i] * mu))
shrinkage <- sapply(1:94, shrink)
shrink <- function(i) mean(alpha/(alpha + hearttransplants$e[i] * mu))
shrinkage <- sapply(1:94, shrink)
plot(log(e), shrinkage)
plot(log(hearttransplants$e), shrinkage)
plot(log(hearttransplants$e), shrinkage, xlim = c(0, 1))
plot(log(hearttransplants$e), shrinkage, ylim = c(0, 1))
mrate <- function(i)
with(hearttransplants, mean(rgamma(1000, y[i] + alpha, e[i] + alpha/mu)))
hospital <- 1:94
meanrate <- sapply(hospital, mrate)
hospital[meanrate == min(meanrate)]
sim.lambda <- function(i)
with(hearttransplants, rgamma(1000, y[i] + alpha, e[i] + alpha/mu))
LAM <- sapply(hospital, sim.lambda)
compare.rates <- function(x) {
nc <- NCOL(x)
ij <- as.matrix(expand.grid(1:nc, 1:nc))
m <- as.matrix(x[ , ij[ , 1]] > x[ , ij[ ,2]])
matrix(colMeans(m), nc, nc, byrow = TRUE)
}
better <- compare.rates(LAM)
better[1:24, 85]
sir.old.new <- function(theta, prior, prior.new) {
log.g <- log(prior(theta))
log.g.new <- log(prior.new(theta))
wt <- exp(log.g.new - log.g - max(log.g.new - log.g))
probs <- wt/sum(wt)
n <- length(probs)
indices <- sample(1:n, size = n, prob = probs, replace = TRUE)
theta[indices]
}
prior <- function(theta)
0.53*exp(theta)/(exp(theta) + 0.53)^2
prior.new <- function(theta)
5*exp(theta)/(exp(theta) + 5)^2
log.alpha <- fitgibbs$par[ , 1]
log.alpha.new <- sir.old.new(log.alpha, prior, prior.new)
draw.graph <- function() {
LOG.ALPHA <- data.frame("prior", log.alpha)
names(LOG.ALPHA) <- c("Prior", "log.alpha")
LOG.ALPHA.NEW <- data.frame("new.prior", log.alpha.new)
names(LOG.ALPHA.NEW) <- c("Prior", "log.alpha")
D <- densityplot(~log.alpha, group = Prior, data = rbind(LOG.ALPHA, LOG.ALPHA.NEW), plot.points = FALSE,
main = "Original Prior and Posterior (solid), New Prior and Posterior (dashed)",
lwd = 4, adjust = 2, lty = c(1, 2), xlab = "log alpha", xlim = c(-3, 5), col = "black")
update(D, panel = function(...) {
panel.curve(prior(x)    , lty = 1, lwd = 2, col = "black")
panel.curve(prior.new(x), lty = 2, lwd = 2, col = "black")
panel.densityplot(...)
})
}
draw.graph()
prob.int.rate <- function(i,log.alpha) {
lami <- rgamma(1000, y[i] + exp(log.alpha), e[i] + exp(log.alpha)/mu)
quantile(lami, c(0.05, 0.95))
}
ind <- c(1, 25, 57, 89)
ci <- sapply(ind, prob.int.rate, log.alpha)
matplot(matrix(log(e[ind]), 2, length(ind), byrow = TRUE), ci,
type = "l", lwd = 4, lty = 1,
xlim = c(6, 9.7), ylim = c(0, 0.002), ylab = "True Rate", xlab = "log(e)")
prob.int.rate <- function(i, log.alpha) {
lami <- with(hearttransplants, rgamma(1000, y[i] + exp(log.alpha), e[i] + exp(log.alpha)/mu))
quantile(lami, c(0.05, 0.95))
}
ind <- c(1, 25, 57, 89)
ci <- sapply(ind, prob.int.rate, log.alpha)
matplot(matrix(log(hearttransplants$e[ind]), 2, length(ind), byrow = TRUE)       , ci,
type = "l", lwd = 4, lty = 1,
xlim = c(6, 9.7), ylim = c(0, 0.002), ylab = "True Rate", xlab = "log(e)")
ci <- sapply(ind, prob.int.rate, log.alpha.new)
matplot(matrix(log(hearttransplants$e[ind]), 2, length(ind), byrow = TRUE) + 0.05, ci,
type = "l", lwd = 4, lty = 3, add = TRUE)
lam94 <- with(hearttransplants, rgamma(1000, y[94] + alpha, e[94] + alpha/mu))
ys94 <- rpois(1000, hearttransplants$e[94]*lam94)
hist(ys94, breaks = seq(-0.5, max(ys94) + 0.5))
lines(y[94]*c(1, 1), c(0, 100), lwd = 3)
lines(hearttransplants$y[94]*c(1, 1), c(0, 100), lwd = 3)
prob.out <- function(i) {
lami <- with(hearttransplants, rgamma(1000, y[i] + alpha, e[i] + alpha/mu))
ysi <- rpois(1000, hearttransplants$e[i]*lami)
pleft  <- sum(ysi <= hearttransplants$y[i])/1000
pright <- sum(ysi >= hearttransplants$y[i])/1000
min(pleft, pright)
}
pout.exchange <- sapply(hospital, prob.out)
plot(pout, pout.exchange, xlab = "P(extreme), equal means", ylab = "P(extreme), exchangeable")
abline(0, 1)
par(pty = "s")
plot(pout, pout.exchange, xlab = "P(extreme), equal means", ylab = "P(extreme), exchangeable")
abline(0, 1)
install.packages("sqldf")
library(sqldf)
sqldf("create table test (id);")
sqldf("create table test (id);", dbname = "test.db")
objects()
rm(bom)
rm(dsw)
rm(ndsw)
rm(today)
rm(vars)
objects()
library(sqldf)
library(sqldf)
DF <- sqldf("create table test (id);", dbname = "test.db")
objects()
DF
class(DF)
mode(DF)
str(DF)
sqldf("attach 'test' as new")
sqldf("create table test (id)", dbname = "test")
sqldf("select * from test", dbname = "test")
rm(DF)
sqldf("CREATE TABLE person (
id INTEGER PRIMARY KEY,
first_name TEXT,
last_name TEXT,
age INTEGER
);")
sqldf("attach 'ex1' as new")
sqldf("CREATE TABLE person (
id INTEGER PRIMARY KEY,
first_name TEXT,
last_name TEXT,
age INTEGER
);" dbname = "ex1")
sqldf("CREATE TABLE person (
id INTEGER PRIMARY KEY,
first_name TEXT,
last_name TEXT,
age INTEGER
);", dbname = "ex1")
ls()
sqldf("select * from person", dbname = "ex1")
sqldf("attach 'ex1' as new")
sqldf("create table person (
id integer primary key,
first_name text,
last_name text,
age integer
);", dbname = "ex1")
sqldf("select * from person", dbname = "ex1")
sqldf("attach 'ex1' as new")
sqldf("CREATE TABLE person (
id INTEGER PRIMARY KEY,
first_name TEXT,
last_name TEXT,
age INTEGER,
gender TEXT,
weight INTEGER,
inches INTEGER
);", dbname = "ex1")
sqldf("select * from person", dbname = "ex1")
sqldf("attach 'ex1' as new")
sqldf("create table person (
id integer primary key,
first_name text,
last_name text,
age integer
);", dbname = "ex1")
sqldf("select * from person", dbname = "ex1")
sqldf("attach 'ex1a' as new")
sqldf("create table person (
id integer primary key,
first_name text,
last_name text,
age integer
);", dbname = "ex1a")
sqldf("select * from person", dbname = "ex1a")
sqldf("attach 'ex1b' as new")
sqldf("CREATE TABLE person (
id INTEGER PRIMARY KEY,
first_name TEXT,
last_name TEXT,
age INTEGER,
gender TEXT,
weight INTEGER,
inches INTEGER
);", dbname = "ex1b")
sqldf("select * from person", dbname = "ex1b")
sqldf("attach 'ex2' as new")
sqldf("CREATE TABLE person (
id INTEGER PRIMARY KEY,
firstName TEXT,
lastName TEXT,
age INTEGER
);", dbname = "ex2")
sqldf("CREATE TABLE personPet (
personId INTEGER,
petId INTEGER
);", dbname = "ex2")
sqldf("CREATE TABLE pet (
id INTEGER PRIMARY KEY,
name TEXT,
breed TEXT,
age INTEGER,
dead INTEGER
);", dbname = "ex2")
sqldf("select * from person", dbname = "ex2")
sqldf("select * from personPet", dbname = "ex2")
sqldf("select * from pet", dbname = "ex2")
library(sqldf)
sqldf("attach 'ex2' as new")
sqldf("CREATE TABLE person (
id INTEGER PRIMARY KEY,
firstName TEXT,
lastName TEXT,
age INTEGER
);", dbname = "ex2")
sqldf("CREATE TABLE person (
id INTEGER PRIMARY KEY,
firstName TEXT,
lastName TEXT,
age INTEGER
);", dbname = "ex2")
submission.to_csv('benchmark.csv', index = False)
library(rattle)
rattle()
- To avoid recomputing a value that is used repeatedly. For example, if you are performing computations involving e, you might want to compute it once and save the result.
To make the connection between the code and the underlying mathematics more apparent. If you are computing the area of a circle, you might want to use a variable named r:
attach(birthwt)
library(MASS)
attach(birthwt)
race <- factor(race, labels = c("white", "black", "other"))
table(ptl)
ptd <- factor(ptl > 0)
table(ftv)
ftv <- factor(ftv)
levels(ftv)[-(1:2)] <- "2+"
table(ftv) # as a check
bwt <- data.frame(low = factor(low), age, lwt, race,
smoke = (smoke > 0), ptd, ht = (ht > 0), ui = (ui > 0), ftv)
detach()
suppressPackageStartupMessages(library(SOAR)) # picky!
suppressPackageStartupMessages(library(MASS))
BirthWt <- within(birthwt, {
race <- factor(race, labels = c("white", "black", "other"))
ptl <- ptl > 0
ftv <- factor(ftv)
levels(ftv)[-(1:2)] <- "2+"
low <- factor(low, labels = c("normal", "low"))
smoke <- (smoke > 0)
ht <- (ht > 0)
ui <- (ui > 0)
bwt <- NULL ## remove actual birth weight
})
Store(BirthWt)
head(BirthWt, 2)
options(show.signif.stars = FALSE)
stepAIC <- function(..., trace = FALSE) # change default
MASS::stepAIC(..., trace = trace)
dropterm <- function(..., sorted = TRUE) # change default
MASS::dropterm(..., sorted = sorted)
BW0 <- glm(low ~ ., binomial, BirthWt)
dropterm(BW0, test = "Chisq")
# Screen for possible interactions:
sBW0 <- stepAIC(BW0, scope = list(lower = ~1, upper = ~.^2))
dropterm(sBW0, test = "Chisq")
# Session information
sessionInfo()
install.packages("compiler")
require(compiler)
vectorized <- function() {
a <- c(1, 1)
b <- c(2, 2)
x <- c(NaN, NaN)
for (i in 1:1000000) {
x <- a + b
}
return()
}
time <- function (N) {
timings <- rep(NA, N)
for (itr in 1:N) {
start <- Sys.time()
vectorized()
end <- Sys.time()
timings[itr] <- end - start
}
return(timings)
}
mean(time(10))
devectorized <- function() {
a <- c(1, 1)
b <- c(2, 2)
x <- c(NaN, NaN)
for (i in 1:1000000) {
for (index in 1:2) {
x[index] <- a[index] + b[index]
}
}
return()
}
time <- function (N) {
timings <- rep(NA, N)
for (itr in 1:N) {
start <- Sys.time()
devectorized()
end <- Sys.time()
timings[itr] <- end - start
}
return(timings)
}
mean(time(10))
require(compiler)
devectorized_cmp <- cmpfun(devectorized)
time_cmp <- function (N) {
timings <- rep(NA, N)
for (itr in 1:N) {
start <- Sys.time()
devectorized_cmp()
end <- Sys.time()
timings[itr] <- end – start
}
return(timings)
}
time_cmp <- function (N) {
timings <- rep(NA, N)
for (itr in 1:N) {
start <- Sys.time()
devectorized_cmp()
end <- Sys.time()
timings[itr] <- end - start
}
return(timings)
}
mean(time_cmp(10))
vectorized_cmp <- cmpfun(vectorized)
time_cmp <- function (N) {
timings <- rep(NA, N)
for (itr in 1:N) {
start <- Sys.time()
vectorized_cmp()
end <- Sys.time()
timings[itr] <- end – start
}
return(timings)
}
time_cmp <- function (N) {
timings <- rep(NA, N)
for (itr in 1:N) {
start <- Sys.time()
vectorized_cmp()
end <- Sys.time()
timings[itr] <- end - start
}
return(timings)
}
mean(time_cmp(10))
sessionInfo()
df1 <- data.frame(ID = c(1, 2), Obs = c(1.0, 2.0))
df2 <- data.frame(ID = c(1, 2), Obs = c(2.0, 3.0))
df3 <- (df1 + df2) / 2
df3
df1 <- data.frame(ID = c(1, 2), Obs = c(1.0, 2.0))
df2 <- data.frame(ID = c(2, 1), Obs = c(3.0, 2.0))
df3 <- (df1 + df2) / 2
df3
df1 <- data.frame(ID = c(1, 2), Obs = c(1.0, 2.0))
df2 <- data.frame(ID = c(2, 1), Obs = c(3.0, 2.0))
df3 <- merge(df1, df2, by = "ID")
df3 <- transform(df3, AvgObs = (Obs.x + Obs.y) / 2)
df3
df1 <- data.frame(ID = c(1, 2), Obs = c(1.0, 2.0))
df2 <- data.frame(ID = c(1, 2, 3), Obs = c(5.0, 6.0, 7.0))
df3 <- merge(df1, df2, by = "ID")
df3 <- transform(df3, AvgObs = (Obs.x + Obs.y) / 2)
df3
rm(diff)
rm("diff")
objects()
setwd("~/GitHub/MATLAB")
objects()
getwd()
